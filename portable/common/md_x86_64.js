const md = {
  ip: '%rbp',
  sp: '%rbx',
  tos: 'XXX_NO_TOS_XXX',
  rsp: 'rsp(%rip)',

  t1: '%rax',
  t2: '%rdx',
  t3: '%rdi',
  t4: '%rsi',

  previous: '0',
  key: 1,

  poprsp(reg) {
    return [
      `movq   ${this.rsp}, ${reg}`,
      `movq   (${reg}), ${reg}`,
      `addq   $8, ${this.rsp}`,
    ];
  },
  pushrsp(reg, thru) {
    return [
      `movq   ${this.rsp}, ${thru}`,
      `subq   $8, ${thru}`,
      `movq   ${thru}, ${this.rsp}`,
      `movq   ${reg}, (${thru})`,
    ];
  },

  next() {
    return [
      `movq (${this.ip}), ${this.t1}`,
      `addq $8, ${this.ip}`,
      `jmp *${this.t1}`,
    ];
  },

  exitNext() {
    return [
      `movq ${this.rsp}, ${this.t1}`,
      `leaq 8(${this.t1}), ${this.t2}`,
      `movq ${this.t2}, ${this.rsp}`,
      `movq (${this.t1}), ${this.ip}`,
      this.next(),
    ];
  },

  nativeWord(prim) {
    const codeName = prim.name;
    const forthName = prim.forthName || prim.name;
    const code = prim.x86_64 || prim.code;
    const length = forthName.length + (prim.immediate ? 512 : 0);

    const ret = [
      `.globl header_${codeName}`,
      `.section .rodata`,
      `.str_${codeName}:`,
      `.string "${forthName}"`,
      `.data`,
      `.align 32`,
      `.type header_${codeName}, @object`,
      `.size header_${codeName}, 32`,
      `header_${codeName}:`,
      `.quad ${this.previous}`,
      `.quad ${length}`,
      `.quad .str_${codeName}`,
      `.quad code_${codeName}`,
      `.globl key_${codeName}`,
      `.align 4`,
      `.type key_${codeName}, @object`,
      `.size key_${codeName}, 4`,
      `key_${codeName}:`,
      `.long ${this.key++}`,
      `.text`,
      `.globl code_${codeName}`,
      `.type code_${codeName}, @function`,
      `code_${codeName}:`,
      code,
      `.size code_${codeName}, .-code_${codeName}`,
    ];
    this.previous = `header_${codeName}`;
    return ret;
  },

  superinstruction(sup) {
    const name = sup.parts.join('_');
    return [
      `.globl	code_superinstruction_${name}`,
      `.type	code_superinstruction_${name}, @function`,
      `code_superinstruction_${name}:`,
      `.cfi_startproc`,
      sup.x86_64 || sup.code,
      `.cfi_endproc`,
      `.size	code_superinstruction_${name}, .-code_superinstruction_${name}`,
    ];
  },

  preamble() {
    function initWord(name) {
      return [
        `movl	key_${name}(%rip), %eax`,
        `leal	-1(%rax), %edx`,
        `movl	key_${name}(%rip), %eax`,
        `movl	%edx, %ecx`,
        `salq	$4, %rcx`,
        `addq	$primitives, %rcx`,
        `movq	$code_${name}, (%rcx)`,
        `movl	%edx, %edx`,
        `salq	$4, %rdx`,
        `addq	$primitives+8, %rdx`,
        `movl	%eax, (%rdx)`,
      ];
    }

    return [
      `.file	"vm.c"`,
      `.comm	_stack_data,131072,64`,
      `.globl	spTop`,
      `.data`,
      `.align 8`,
      `.type	spTop, @object`,
      `.size	spTop, 8`,
      `spTop:`,
      `.quad	_stack_data+131072`,
      `.comm	sp,8,8`,
      `.comm	_stack_return,8192,64`,
      `.globl	rspTop`,
      `.align 8`,
      `.type	rspTop, @object`,
      `.size	rspTop, 8`,
      `rspTop:`,
      `.quad	_stack_return+8192`,
      `.comm	rsp,8,8`,
      `.comm	ip,8,8`,
      `.comm	cfa,8,8`,
      `.comm	ca,8,8`,
      `.globl	firstQuit`,
      `.type	firstQuit, @object`,
      `.size	firstQuit, 1`,
      `firstQuit:`,
      `.byte	1`,
      `.globl	quitTop`,
      `.bss`,
      `.align 8`,
      `.type	quitTop, @object`,
      `.size	quitTop, 8`,
      `quitTop:`,
      `.zero	8`,
      `.globl	quitTopPtr`,
      `.data`,
      `.align 8`,
      `.type	quitTopPtr, @object`,
      `.size	quitTopPtr, 8`,
      `quitTopPtr:`,
      `.quad	quitTop`,
      `.comm	dsp,8,8`,
      `.comm	state,8,8`,
      `.comm	base,8,8`,

      // A word list is a linked list of word headers.
      // Each word list is a cell that points to the first header.
      // The indirection is needed so that a wordlist has a fixed identity,
      // even as it grows.
      // searchIndex is the index of the topmost wordlist in the search order.
      // searchArray is the buffer, with room for 16 searches.
      // compilationWordlist points to the current compilation wordlist.
      // Both of those default to the main Forth wordlist.
      // That main wordlist is pre-allocated as forthWordlist.
      `.comm   searchArray,128,8`,
      `.comm   searchIndex,8,8`,
      `.comm   compilationWordlist,8,8`,
      `.comm   forthWordlist,8,8`,
      `.comm   lastWord,8,8`,
      `.comm	parseBuffers,8192,32`,
      `.comm	inputSources,1024,32`,
      `.comm	inputIndex,8,8`,
      `.comm	c1,8,8`,
      `.comm	c2,8,8`,
      `.comm	c3,8,8`,
      `.comm	ch1,1,1`,
      `.comm	str1,8,8`,
      `.comm	strptr1,8,8`,
      `.comm	tempSize,8,8`,
      `.comm	tempHeader,8,8`,
      `.comm	tempBuf,256,32`,
      `.comm	numBuf,16,16`,
      `.comm	tempFile,8,8`,
      `.comm	tempStat,144,32`,
      `.comm	quit_inner,8,8`,
      `.comm	timeVal,16,16`,
      `.comm	i64,8,8`,
      `.comm	old_tio,60,32`,
      `.comm	new_tio,60,32`,
      `.globl	primitive_count`,
      `.align 4`,
      `.type	primitive_count, @object`,
      `.size	primitive_count, 4`,
      `primitive_count:`,
      `.long	120`,
      `.globl	queue`,
      `.bss`,
      `.align 8`,
      `.type	queue, @object`,
      `.size	queue, 8`,
      `queue:`,
      `.zero	8`,
      `.globl	queueTail`,
      `.align 8`,
      `.type	queueTail, @object`,
      `.size	queueTail, 8`,
      `queueTail:`,
      `.zero	8`,
      `.comm	tempQueue,8,8`,
      `.comm	queueSource,160,32`,
      `.globl	next_queue_source`,
      `.align 4`,
      `.type	next_queue_source, @object`,
      `.size	next_queue_source, 4`,
      `next_queue_source:`,
      `.zero	4`,
      `.globl	queue_length`,
      `.align 4`,
      `.type	queue_length, @object`,
      `.size	queue_length, 4`,
      `queue_length:`,
      `.zero	4`,
      `.comm	primitives,4096,32`,
      `.comm	superinstructions,4096,32`,
      `.globl	nextSuperinstruction`,
      `.align 4`,
      `.type	nextSuperinstruction, @object`,
      `.size	nextSuperinstruction, 4`,
      `nextSuperinstruction:`,
      `.zero	4`,
      `.comm	key1,4,4`,
      `.section	.rodata`,
      `.LC0:`,
      `.string	"%s"`,
      `.text`,
      `.globl	print`,
      `.type	print, @function`,
      `print:`,
      `.LFB2:`,
      `.cfi_startproc`,
      `subq	$24, %rsp`,
      `.cfi_def_cfa_offset 32`,
      `movq	%rdi, 8(%rsp)`,
      `movq	%rsi, (%rsp)`,
      `movq	(%rsp), %rax`,
      `addq	$1, %rax`,
      `movq	%rax, %rdi`,
      `call	malloc@PLT`,
      `movq	%rax, str1(%rip)`,
      `movq	(%rsp), %rdx`,
      `movq	8(%rsp), %rax`,
      `movq	%rax, %rsi`,
      `movq	str1(%rip), %rdi`,
      `call	strncpy@PLT`,
      `movq	str1(%rip), %rdx`,
      `movq	(%rsp), %rax`,
      `addq	%rdx, %rax`,
      `movb	$0, (%rax)`,
      `movq	str1(%rip), %rsi`,
      `movl	$.LC0, %edi`,
      `movl	$0, %eax`,
      `call	printf@PLT`,
      `movq	str1(%rip), %rdi`,
      `call	free@PLT`,
      `nop`,
      `addq	$24, %rsp`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE2:`,
      `.size	print, .-print`,

      // Refill
      `.section	.rodata`,
      `.align 16`,
      `.LC42:`,
      `.string	"> "`,
      `.text`,
      `.globl	refill_`,
      `.type	refill_, @function`,
      `refill_:`,
      `.LFB43:`,
      `.cfi_startproc`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$-1, %rax`,
      `jne	.L54`,
      `subq	$1, inputIndex(%rip)`,
      `movq	rsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, rsp(%rip)`,
      `movq	(%rax), %rbp`,
      this.next(),
      `.L54:`,
      `pushq	%r12`,
      `.cfi_def_cfa_offset 16`,
      `.cfi_offset 3, -16`,
      `subq	$16, %rsp`,
      `.cfi_def_cfa_offset 32`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.L55`,
      `movl	$.LC42, %edi`,

      // readline uses xmm0 kinds of instructions, which requires the
      // target (the stack in this case) be 16-byte aligned.
      // So I move the stack here and save its value in %r14, which is
      // callee-saved.
      `movq    %rsp, %r14`,
      `movq    $15, %rax`,
      `notq    %rax`,
      `andq    %rax, %rsp`,

      `call	readline@PLT`,
      `movq    %rax, str1(%rip)`,
      // Restore %rsp
      `movq    %r14, %rsp`,

      `movq	inputIndex(%rip), %r12`,
      `movq	str1(%rip), %rdi`,
      `call	strlen@PLT`,
      `movq	%rax, %rdx`,
      `movq	%r12, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$5, %rdx`,
      `leaq	inputSources+24(%rdx), %rcx`,
      `movq	%rax, %rdx`,
      `movq	str1(%rip), %rsi`,
      `movq	(%rcx), %rdi`,
      `call	strncpy@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	str1(%rip), %rdi`,
      `call	free@PLT`,
      `movq	$-1, %rax`,
      `jmp	.L56`,
      `.L55:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `andl	$1, %eax`,
      `testq	%rax, %rax`,
      `je	.L57`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `andq	$-2, %rax`,
      `movq	%rax, 8(%rsp)`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rdx`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jb	.L58`,
      `subq	$1, inputIndex(%rip)`,
      `movl	$0, %eax`,
      `jmp	.L56`,
      `.L58:`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	%rax, str1(%rip)`,
      `jmp	.L59`,
      `.L61:`,
      `addq	$1, str1(%rip)`,
      `.L59:`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rdx`,
      `movq	str1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jbe	.L60`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$10, %al`,
      `jne	.L61`,
      `.L60:`,
      `movq	inputIndex(%rip), %rcx`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	str1(%rip), %rdx`,
      `subq	%rax, %rdx`,
      `movq	%rcx, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rdx`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	inputIndex(%rip), %rcx`,
      `salq	$5, %rcx`,
      `addq	$inputSources+24, %rcx`,
      `movq	%rax, %rsi`,
      `movq	(%rcx), %rdi`,
      `call	strncpy@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rdx`,
      `movq	str1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jbe	.L62`,
      `movq	str1(%rip), %rax`,
      `addq	$1, %rax`,
      `jmp	.L63`,
      `.L62:`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rax`,
      `.L63:`,
      `movq	8(%rsp), %rdx`,
      `movq	%rax, (%rdx)`,
      `movq	$-1, %rax`,
      `jmp	.L56`,
      `.L57:`,
      `movq	$0, str1(%rip)`,
      `movq	$0, tempSize(%rip)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `movq	%rax, %rdx`,
      `movl	$tempSize, %esi`,
      `movl	$str1, %edi`,
      `call	getline@PLT`,
      `movq	%rax, c1(%rip)`,
      `movq	c1(%rip), %rax`,
      `cmpq	$-1, %rax`,
      `jne	.L64`,
      `subq	$1, inputIndex(%rip)`,
      `movl	$0, %eax`,
      `jmp	.L56`,
      `.L64:`,
      `movq	str1(%rip), %rdx`,
      `movq	c1(%rip), %rax`,
      `addq	%rdx, %rax`,
      `subq	$1, %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$10, %al`,
      `jne	.L65`,
      `subq	$1, c1(%rip)`,
      `.L65:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	c1(%rip), %rdx`,
      `movq	str1(%rip), %rsi`,
      `movq	(%rax), %rdi`,
      `call	strncpy@PLT`,
      `movq	str1(%rip), %rdi`,
      `call	free@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `leaq	inputSources(%rax), %rdx`,
      `movq	c1(%rip), %rax`,
      `movq	%rax, (%rdx)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	$-1, %rax`,
      `.L56:`,
      `addq	$16, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `popq	%r12`,
      `.cfi_restore 3`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE43:`,
      `.size	refill_, .-refill_`,

      // Parsing etc.
      `.globl	parse_`,
      `.type	parse_, @function`,
      `parse_:`,
      `.LFB67:`,
      `.cfi_startproc`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jl	.L100`,
      `movq	$0, (%rbx)`,
      `subq	$8, %rbx`,
      `movq	$0, (%rbx)`,
      `jmp	.L106`,
      `.L100:`,
      `movq	(%rbx), %rax`,
      `movb	%al, ch1(%rip)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `addq	%rdx, %rax`,
      `movq	%rax, str1(%rip)`,
      `movq	$0, c1(%rip)`,
      `jmp	.L102`,
      `.L104:`,
      `movq	inputIndex(%rip), %rax`,
      `movq	%rax, %rdx`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `addq	$1, %rdx`,
      `movq	%rdx, (%rax)`,
      `addq	$1, c1(%rip)`,
      `.L102:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L103`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `movzbl	(%rdx,%rax), %edx`,
      `movzbl	ch1(%rip), %eax`,
      `cmpb	%al, %dl`,
      `jne	.L104`,
      `.L103:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L105`,
      `movq	inputIndex(%rip), %rax`,
      `movq	%rax, %rdx`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `addq	$1, %rdx`,
      `movq	%rdx, (%rax)`,
      `.L105:`,
      `movq	str1(%rip), %rdx`,
      `movq	%rdx, (%rbx)`,
      `subq	$8, %rbx`,
      `movq	c1(%rip), %rax`,
      `movq	%rax, (%rbx)`,
      `.L106:`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE67:`,
      `.size	parse_, .-parse_`,
      `.globl	parse_name_`,
      `.type	parse_name_, @function`,
      `parse_name_:`,
      `.LFB68:`,
      `.cfi_startproc`,
      `jmp	.L108`,
      `.L110:`,
      `movq	inputIndex(%rip), %rax`,
      `movq	%rax, %rdx`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `addq	$1, %rdx`,
      `movq	%rdx, (%rax)`,
      `.L108:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L109`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `movzbl	(%rdx,%rax), %eax`,
      `cmpb	$32, %al`,
      `je	.L110`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `movzbl	(%rdx,%rax), %eax`,
      `cmpb	$9, %al`,
      `je	.L110`,
      `.L109:`,
      `movq	$0, c1(%rip)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `addq	%rdx, %rax`,
      `movq	%rax, str1(%rip)`,
      `jmp	.L111`,
      `.L113:`,
      `movq	inputIndex(%rip), %rax`,
      `movq	%rax, %rdx`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `addq	$1, %rdx`,
      `movq	%rdx, (%rax)`,
      `addq	$1, c1(%rip)`,
      `.L111:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L112`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rax`,
      `movzbl	(%rdx,%rax), %eax`,
      `cmpb	$32, %al`,
      `jne	.L113`,
      `.L112:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	(%rax), %rdx`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L114`,
      `movq	inputIndex(%rip), %rax`,
      `movq	%rax, %rdx`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `addq	$1, %rdx`,
      `movq	%rdx, (%rax)`,
      `.L114:`,
      `subq    $16, %rbx`,
      `movq	str1(%rip), %rax`,
      `movq	%rax, 8(%rbx)`,
      `movq	c1(%rip), %rax`,
      `movq	%rax, (%rbx)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE68:`,
      `.size	parse_name_, .-parse_name_`,
      `.globl	to_number_int_`,
      `.type	to_number_int_, @function`,
      `to_number_int_:`,
      `.LFB69:`,
      `.cfi_startproc`,
      `movq	$0, c1(%rip)`,
      `jmp	.L116`,
      `.L117:`,
      `movq	c1(%rip), %rax`,
      `movq	24(%rbx), %rsi`,
      `movq	c1(%rip), %rdx`,
      `sall	$3, %edx`,
      `movl	%edx, %ecx`,
      `shrq	%cl, %rsi`,
      `movq	%rsi, %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `movq	c1(%rip), %rax`,
      `addq	$8, %rax`,
      `movq	16(%rbx), %rdx`,
      `movq	%rdx, %rsi`,
      `movq	c1(%rip), %rdx`,
      `sall	$3, %edx`,
      `movl	%edx, %ecx`,
      `shrq	%cl, %rsi`,
      `movq	%rsi, %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `addq	$1, c1(%rip)`,
      `.L116:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$7, %rax`,
      `jle	.L117`,
      `jmp	.L118`,
      `.L126:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `movsbq	%al, %rax`,
      `movq	%rax, c1(%rip)`,
      `movq	c1(%rip), %rax`,
      `cmpq	$47, %rax`,
      `jle	.L119`,
      `movq	c1(%rip), %rax`,
      `cmpq	$57, %rax`,
      `jg	.L119`,
      `subq	$48, c1(%rip)`,
      `jmp	.L120`,
      `.L119:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$64, %rax`,
      `jle	.L121`,
      `movq	c1(%rip), %rax`,
      `cmpq	$90, %rax`,
      `jg	.L121`,
      `movq	c1(%rip), %rax`,
      `subq	$55, %rax`,
      `movq	%rax, c1(%rip)`,
      `jmp	.L120`,
      `.L121:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$96, %rax`,
      `jle	.L122`,
      `movq	c1(%rip), %rax`,
      `cmpq	$122, %rax`,
      `jg	.L122`,
      `movq	c1(%rip), %rax`,
      `subq	$87, %rax`,
      `movq	%rax, c1(%rip)`,
      `.L120:`,
      `movq	c1(%rip), %rdx`,
      `movq	tempSize(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.L129`,
      `movq	$0, c3(%rip)`,
      `jmp	.L124`,
      `.L125:`,
      `movq	c3(%rip), %rax`,
      `addq	$numBuf, %rax`,
      `movzbl	(%rax), %eax`,
      `movzbl	%al, %eax`,
      `imulq	tempSize(%rip), %rax`,
      `movq	%rax, %rdx`,
      `movq	c1(%rip), %rax`,
      `addq	%rdx, %rax`,
      `movq	%rax, c2(%rip)`,
      `movq	c3(%rip), %rax`,
      `movq	c2(%rip), %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `movq	c2(%rip), %rax`,
      `sarq	$8, %rax`,
      `movzbl	%al, %eax`,
      `movq	%rax, c1(%rip)`,
      `addq	$1, c3(%rip)`,
      `.L124:`,
      `movq	c3(%rip), %rax`,
      `cmpq	$15, %rax`,
      `jle	.L125`,
      `movq	(%rbx), %rax`,
      `subq	$1, %rax`,
      `movq	%rax, (%rbx)`,
      `addq	$1, str1(%rip)`,
      `.L118:`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jg	.L126`,
      `jmp	.L122`,
      `.L129:`,
      `nop`,
      `.L122:`,
      `movq	$0, 16(%rbx)`,
      `movq	$0, 24(%rbx)`,
      `movq	$0, c1(%rip)`,
      `jmp	.L127`,
      `.L128:`,
      `movq	c1(%rip), %rax`,
      `addq	$numBuf, %rax`,
      `movzbl	(%rax), %eax`,
      `movzbl	%al, %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `salq	%cl, %rdx`,
      `movq	%rdx, %rax`,

      `orq     24(%rbx), %rax`,
      `movq    %rax, 24(%rbx)`,

      `movq	c1(%rip), %rax`,
      `addq	$8, %rax`,
      `movzbl	numBuf(%rax), %eax`,
      `movzbl	%al, %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `salq	%cl, %rdx`,
      `movq	%rdx, %rax`,
      `movq	%rax, %rcx`,

      `orq     %rcx, 16(%rbx)`,
      `addq	$1, c1(%rip)`,
      `.L127:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$7, %rax`,
      `jle	.L128`,
      `movq	str1(%rip), %rax`,
      `movq	%rax, 8(%rbx)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE69:`,
      `.size	to_number_int_, .-to_number_int_`,
      `.globl	to_number_`,
      `.type	to_number_, @function`,
      `to_number_:`,
      `.LFB70:`,
      `.cfi_startproc`,
      `movq	base(%rip), %rax`,
      `movq	%rax, tempSize(%rip)`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, str1(%rip)`,
      `call	to_number_int_@PLT`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE70:`,
      `.size	to_number_, .-to_number_`,
      `.globl	parse_number_`,
      `.type	parse_number_, @function`,
      `parse_number_:`,
      `.LFB71:`,
      `.cfi_startproc`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, str1(%rip)`,
      `movq	base(%rip), %rax`,
      `movq	%rax, tempSize(%rip)`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$36, %al`,
      `je	.L132`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$35, %al`,
      `je	.L132`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$37, %al`,
      `jne	.L133`,
      `.L132:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$36, %al`,
      `je	.L134`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$35, %al`,
      `jne	.L135`,
      `movl	$10, %eax`,
      `jmp	.L137`,
      `.L135:`,
      `movl	$2, %eax`,
      `jmp	.L137`,
      `.L134:`,
      `movl	$16, %eax`,
      `.L137:`,
      `movq	%rax, tempSize(%rip)`,
      `addq	$1, str1(%rip)`,
      `subq	$1, (%rbx)`,
      `jmp	.L138`,
      `.L133:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$39, %al`,
      `jne	.L138`,
      `subq    $3, (%rbx)`,
      `addq    $3, 8(%rbx)`,
      `movq	str1(%rip), %rax`,
      `addq	$1, %rax`,
      `movsbq	(%rax), %rax`,
      `movq	%rax, 24(%rbx)`,
      `jmp	.L131`,
      `.L138:`,
      `movb	$0, ch1(%rip)`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$45, %al`,
      `jne	.L140`,
      `subq    $1, (%rbx)`,
      `addq	$1, str1(%rip)`,
      `movb	$1, ch1(%rip)`,
      `.L140:`,
      `call	to_number_int_@PLT`,
      `movzbl	ch1(%rip), %eax`,
      `testb	%al, %al`,
      `je	.L131`,

      `notq    16(%rbx)`,
      `movq    24(%rbx), %rax`,
      `notq    %rax`,
      `addq    $1, %rax`,
      `movq    %rax, 24(%rbx)`,

      `testq	%rax, %rax`,
      `jne	.L131`,
      `addq	$1, 16(%rbx)`,
      `.L131:`,
      `ret`,
      `.cfi_endproc`,
      `.LFE71:`,
      `.size	parse_number_, .-parse_number_`,
      `.globl	find_`,
      `.type	find_, @function`,
      `find_:`,
      `movq    searchIndex(%rip), %r12    # r12 is reserved for the index.`,
      `.LF159:`,
      `leaq    searchArray(%rip), %rax`,
      `movq    (%rax,%r12,8), %rax`,
      `movq    (%rax), %rax`,
      `movq    %rax, tempHeader(%rip)   # Store it in tempHeader.`,
      `jmp     .LF151`,

      `.LF156:`,
      `movq    tempHeader(%rip), %rax`,
      `movq    8(%rax), %rax  # The length word.`,
      `andl	$511, %eax     # The length/hidden mask`,
      `movq    (%rbx), %rcx`,
      `cmpq    %rcx, %rax`,
      `jne     .LF152`,

      `# If we're still here, they're the same length and not hidden.`,
      `find_debug:`,
      `movq    tempHeader(%rip), %rax`,
      `movq    16(%rax), %rdi  # 1st arg: pointer to this word's name.`,
      `movq    8(%rbx), %rsi   # 2nd arg: pointer to target name.`,
      `movq    (%rbx), %rdx    # 3rd arg: length.`,

      `# %rsp needs to be aligned to 16 bytes for C calls, but it already is,`,
      `# because find_ is a C call itself.`,
      `call strncasecmp@PLT`,
      `testl   %eax, %eax  # ZF=1 when the response was 0, meaning equal.`,
      `jne  .LF152  # If it's not equal, we didn't find it.`,

      `# If they are equal, we found it.`,
      `find_found:`,
      `movq    tempHeader(%rip), %rax`,
      `addq    $24, %rax`,
      `movq    %rax, 8(%rbx)   # CFA in next-but-top.`,

      `movq    tempHeader(%rip), %rax`,
      `movq    8(%rax), %rax   # Length`,
      `andl    $512, %eax      # Immediate flag`,
      `testl   %eax, %eax      # ZF=1 when not immediate`,
      `jne     .LF153          # Set 1 when immediate`,
      `movq    $-1, %rax`,
      `jmp     .LF154`,
      `.LF153:`,
      `movq    $1, %rax`,
      `.LF154:`,
      `movq    %rax, (%rbx)`,
      `jmp     .LF149`,

      `.LF152: # Mismatch, keep searching this linked list.`,
      `movq    tempHeader(%rip), %rax`,
      `movq    (%rax), %rax`,
      `movq    %rax, tempHeader(%rip)`,

      `.LF151:`,
      `movq    tempHeader(%rip), %rax`,
      `testq   %rax, %rax`,
      `jne     .LF156  # Nonzero, so loop back.`,
      `.LF150: # Reached the end of a wordlist. Try the next one, if any.`,
      `testq   %r12, %r12`,
      `je      .LF158  # Index = 0, bail.`,
      `subq    $1, %r12 # If nonzero, subtract and loop.`,
      `jmp     .LF159`,

      `.LF160:`,
      `nop`,
      `.LF158: # Run out of wordlists too.`,
      `movq $0, %rax`,
      `movq %rax, 8(%rbx) # 0 underneath`,
      `movq %rax, (%rbx)  # 0 on top`,
      `.LF149: # Returning`,
      `ret`,
      `.size	find_, .-find_`,



      `.globl	key_call_`,
      `.data`,
      `.align 4`,
      `.type	key_call_, @object`,
      `.size	key_call_, 4`,
      `key_call_:`,
      `.long	100`,
      `.text`,
      `.globl	call_`,
      `.type	call_, @function`,
      `call_:`,
      `.LFB88:`,
      `.cfi_startproc`,
      `movq	(%rbp), %rax`,
      `addq    $8, %rbp`,
      `movq	rsp(%rip), %r12`,
      `subq	$8, %r12`,
      `movq	%r12, rsp(%rip)`,
      `movq	%rbp, (%r12)`,
      `movq	%rax, %rbp`,
      this.next(),
      `.cfi_endproc`,
      `.LFE88:`,
      `.size	call_, .-call_`,


      `.globl	lookup_primitive`,
      `.type	lookup_primitive, @function`,
      `lookup_primitive:`,
      `.LFB89:`,
      `.cfi_startproc`,
      `movq	$0, c2(%rip)`,
      `jmp	.L179`,
      `.L182:`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$primitives, %rax`,
      `movq	(%rax), %rdx`,
      `movq	c1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jne	.L180`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$primitives+8, %rax`,
      `movl	(%rax), %eax`,
      `movl	%eax, key1(%rip)`,
      `jmp	.L183`,
      `.L180:`,
      `addq	$1, c2(%rip)`,
      `.L179:`,
      `movl	primitive_count(%rip), %eax`,
      `movslq	%eax, %rdx`,
      `movq	c2(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jg	.L182`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `movl	$40, %edi`,
      `call	exit@PLT`,
      `.L183:`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE89:`,
      `.size	lookup_primitive, .-lookup_primitive`,


      `.globl	drain_queue_`,
      `.type	drain_queue_, @function`,
      `drain_queue_:`,
      `.LFB90:`,
      `.cfi_startproc`,
      `movl	$0, key1(%rip)`,
      `movq	queue(%rip), %rax`,
      `movq	%rax, tempQueue(%rip)`,
      `movq	$0, c1(%rip)`,
      `jmp	.L188`,
      `.L189:`,
      `movq	tempQueue(%rip), %rax`,
      `movl	24(%rax), %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `sall	%cl, %edx`,
      `movl	%edx, %eax`,
      `orl	%eax, key1(%rip)`,
      `addq	$1, c1(%rip)`,
      `movq	tempQueue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, tempQueue(%rip)`,
      `.L188:`,
      `movq	tempQueue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.L189`,
      `jmp	.L190`,
      `.L199:`,
      `movq	$0, c2(%rip)`,
      `jmp	.L191`,
      `.L198:`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$superinstructions+8, %rax`,
      `movl	(%rax), %edx`,
      `movl	key1(%rip), %eax`,
      `cmpl	%eax, %edx`,
      `jne	.L192`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	c2(%rip), %rdx`,
      `salq	$4, %rdx`,
      `addq	$superinstructions, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `jmp	.L193`,
      `.L195:`,
      `movq	queue(%rip), %rax`,
      `movzbl	8(%rax), %eax`,
      `testb	%al, %al`,
      `je	.L194`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	16(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `.L194:`,
      `movq	queue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queue(%rip)`,
      `subl	$1, queue_length(%rip)`,
      `subq	$1, c1(%rip)`,
      `.L193:`,
      `movq	c1(%rip), %rax`,
      `testq	%rax, %rax`,
      `jg	.L195`,
      `movq	queue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.L202`,
      `movq	$0, queueTail(%rip)`,
      `jmp	.L202`,
      `.L192:`,
      `addq	$1, c2(%rip)`,
      `.L191:`,
      `movl	nextSuperinstruction(%rip), %eax`,
      `movslq	%eax, %rdx`,
      `movq	c2(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jg	.L198`,
      `subq	$1, c1(%rip)`,
      `movl	$4, %eax`,
      `subq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	$-1, %edx`,
      `movl	%eax, %ecx`,
      `shrl	%cl, %edx`,
      `movl	%edx, %eax`,
      `andl	%eax, key1(%rip)`,
      `.L190:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$1, %rax`,
      `jg	.L199`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `movq	queue(%rip), %rax`,
      `movzbl	8(%rax), %eax`,
      `testb	%al, %al`,
      `je	.L200`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	16(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `.L200:`,
      `movq	queue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queue(%rip)`,
      `movq	queue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.L201`,
      `movq	$0, queueTail(%rip)`,
      `.L201:`,
      `subl	$1, queue_length(%rip)`,
      `jmp	.L187`,
      `.L202:`,
      `nop`,
      `.L187:`,
      `ret`,
      `.cfi_endproc`,
      `.LFE90:`,
      `.size	drain_queue_, .-drain_queue_`,


      `.globl	bump_queue_tail_`,
      `.type	bump_queue_tail_, @function`,
      `bump_queue_tail_:`,
      `.LFB91:`,
      `.cfi_startproc`,
      `movq	queueTail(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.L204`,
      `movl	next_queue_source(%rip), %eax`,
      `leal	1(%rax), %edx`,
      `movl	%edx, next_queue_source(%rip)`,
      `movslq	%eax, %rdx`,
      `movq	%rdx, %rax`,
      `salq	$2, %rax`,
      `addq	%rdx, %rax`,
      `salq	$3, %rax`,
      `addq	$queueSource, %rax`,
      `movq	%rax, queueTail(%rip)`,
      `movq	queueTail(%rip), %rax`,
      `movq	%rax, queue(%rip)`,
      `jmp	.L205`,
      `.L204:`,
      `movq	queueTail(%rip), %rcx`,
      `movl	next_queue_source(%rip), %eax`,
      `leal	1(%rax), %edx`,
      `movl	%edx, next_queue_source(%rip)`,
      `movslq	%eax, %rdx`,
      `movq	%rdx, %rax`,
      `salq	$2, %rax`,
      `addq	%rdx, %rax`,
      `salq	$3, %rax`,
      `addq	$queueSource, %rax`,
      `movq	%rax, 32(%rcx)`,
      `movq	queueTail(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queueTail(%rip)`,
      `.L205:`,
      `movq	queueTail(%rip), %rax`,
      `movq	$0, 32(%rax)`,
      `andl	$3, next_queue_source(%rip)`,
      `addl	$1, queue_length(%rip)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE91:`,
      `.size	bump_queue_tail_, .-bump_queue_tail_`,


      `.globl	compile_`,
      `.type	compile_, @function`,
      `compile_:`,
      `.LFB92:`,
      `.cfi_startproc`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$3, %eax`,
      `jle	.L207`,
      `call	drain_queue_@PLT`,
      `.L207:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	(%rbx), %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$code_docol, %rax`,
      `jne	.L208`,
      `movq	queueTail(%rip), %rax`,
      `movq	$call_, (%rax)`,
      `movb	$1, 8(%rax)`,
      `movq	%rax, %rdx`,

      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `addq	$8, %rax`,
      `movq	%rax, 16(%rdx)`,

      `movq	queueTail(%rip), %rax`,
      `movl	key_call_(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `jmp	.L213`,
      `.L208:`,
      `movq	(%rbx), %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$code_dodoes, %rax`,
      `jne	.L210`,
      `movq	queueTail(%rip), %rax`,
      `movq	$code_dolit, (%rax)`,
      `movb	$1, 8(%rax)`,

      `movq	(%rbx), %rdx`,
      `addq	$16, %rdx`,
      `movq	%rdx, 16(%rax)`,
      `movl	key_dolit(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `movq	(%rbx), %rax`,
      `addq	$8, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `je	.L211`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$4, %eax`,
      `jne	.L212`,
      `call	drain_queue_@PLT`,
      `.L212:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	$call_, (%rax)`,
      `movb	$1, 8(%rax)`,
      `movq	(%rbx), %rdx`,
      `addq	$8, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, 16(%rax)`,
      `movl	key_call_(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `.L211:`,
      `addq	$8, %rbx`,
      `jmp	.L213`,
      `.L210:`,
      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `movq	(%rax), %rax`,
      `movq	%rax, c1(%rip)`,
      `movl	$0, %eax`,
      `call	lookup_primitive@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	c1(%rip), %rdx`,
      `movq	%rdx, (%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movb	$0, 8(%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movl	key1(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `.L213:`,
      `nop`,
      `addq	$8, %rsp`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE92:`,
      `.size	compile_, .-compile_`,


      `.globl	compile_lit_`,
      `.type	compile_lit_, @function`,
      `compile_lit_:`,
      `.LFB93:`,
      `.cfi_startproc`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$3, %eax`,
      `jle	.L216`,
      `call	drain_queue_@PLT`,
      `.L216:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	$code_dolit, (%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movb	$1, 8(%rax)`,
      `movq	queueTail(%rip), %rdx`,
      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `movq	%rax, 16(%rdx)`,
      `movq	queueTail(%rip), %rax`,
      `movl	key_dolit(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE93:`,
      `.size	compile_lit_, .-compile_lit_`,

      `.comm	savedString,8,8`,
      `.comm	savedLength,8,8`,
      `.section	.rodata`,
      `.LC84:`,
      `.string	"  ok"`,
      `.LC85:`,
      `.string	"*** Unrecognized word: %s\\n"`,

      `.text`,
      `.globl	quit_`,
      `.type	quit_, @function`,
      `quit_:`,
      `.LFB94:`,
      `.cfi_startproc`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `.L218:`,
      `movq	spTop(%rip), %rbx`,
      `movq	rspTop(%rip), %rax`,
      `movq	%rax, rsp(%rip)`,
      `movq	$0, state(%rip)`,
      `movzbl	firstQuit(%rip), %eax`,
      `testb	%al, %al`,
      `jne	.L219`,
      `movq	$0, inputIndex(%rip)`,
      `.L219:`,
      `movq	$.L220, quit_inner(%rip)`,
      `call	refill_@PLT`,
      `.L220:`,
      `call	parse_name_@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.L233`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.L223`,
      `movl	$.LC84, %edi`,
      `call	puts@PLT`,
      `.L223:`,
      `addq	$16, %rbx`,
      `call	refill_@PLT`,
      `jmp	.L220`,
      `.L233:`,
      `nop`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, savedString(%rip)`,
      `movq	(%rbx), %rax`,
      `movq	%rax, savedLength(%rip)`,
      `call	find_@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.L224`,
      `subq	$16, %rbx`,
      `movq	savedLength(%rip), %rax`,
      `movq	%rax, (%rbx)`,
      `movq	savedString(%rip), %rax`,
      `movq	%rax, 8(%rbx)`,
      `call	parse_number_@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.L225`,
      `movq	state(%rip), %rax`,
      `cmpq	$1, %rax`,
      `jne	.L226`,
      `addq	$24, %rbx`,
      `movl	$0, %eax`,
      `call	compile_lit_@PLT`,
      `jmp	.L220`,
      `.L226:`,
      `addq	$24, %rbx`,
      `jmp	.L220`,
      `.L225:`,
      `movq	savedLength(%rip), %rdx`,
      `movq	savedString(%rip), %rsi`,
      `movl	$tempBuf, %edi`,
      `call	strncpy@PLT`,
      `movq	savedLength(%rip), %rax`,
      `movb	$0, tempBuf(%rax)`,
      `movl	$tempBuf, %edx`,
      `movl	$.LC85, %esi`,
      `movq	stderr(%rip), %rdi`,
      `movl	$0, %eax`,
      `call	fprintf@PLT`,
      `jmp	.L218`,
      `.L224:`,
      `movq	(%rbx), %rax`,
      `cmpq	$1, %rax`,
      `je	.L229`,
      `movq	state(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.L230`,
      `.L229:`,
      `movl	$.L220, %eax`,
      `movq	%rax, quitTop(%rip)`,
      `movq	$quitTop, %rbp`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, cfa(%rip)`,
      `addq	$16, %rbx`,
      `movq	cfa(%rip), %rax`,
      `movq	(%rax), %rax`,
      `#APP`,
      `# 1438 "vm.c" 1`,
      `jmpq *%rax`,
      `# 0 "" 2`,
      `#NO_APP`,
      `.L230:`,
      `addq	$8, %rbx`,
      `movl	$0, %eax`,
      `call	compile_@PLT`,
      `jmp	.L220`,
      `.cfi_endproc`,
      `.LFE94:`,
      `.size	quit_, .-quit_`,


      `.globl	file_modes`,
      `.section	.rodata`,
      `.LC96:`,
      `.string	"r"`,
      `.LC97:`,
      `.string	"r+"`,
      `.LC98:`,
      `.string	"rb"`,
      `.LC99:`,
      `.string	"r+b"`,
      `.LC100:`,
      `.string	"w+"`,
      `.LC101:`,
      `.string	"w"`,
      `.LC102:`,
      `.string	"w+b"`,
      `.data`,
      `.align 32`,
      `.type	file_modes, @object`,
      `.size	file_modes, 128`,
      `file_modes:`,
      `.quad	0`,
      `.quad	.LC96`,
      `.quad	.LC97`,
      `.quad	.LC97`,
      `.quad	0`,
      `.quad	.LC98`,
      `.quad	.LC99`,
      `.quad	.LC99`,
      `.quad	0`,
      `.quad	.LC100`,
      `.quad	.LC101`,
      `.quad	.LC100`,
      `.quad	0`,
      `.quad	.LC102`,
      `.quad	.LC81`,
      `.quad	.LC102`,

      `.section	.rodata`,
      `.align 8`,
      `.LC117:`,
      `.string	"*** Colon definition with no name\\n"`,


      `.LFE123:`,
      `.section	.rodata`,
      `.align 8`,
      `.LC131:`,
      `.string	"Could not load input file: %s\\n"`,
      `.LC81:`,
      `.string	"wb"`,
      `.align 8`,
      `.LC82:`,
      `.string	"*** Failed to open file for writing: %s\\n"`,
      `.text`,
      `.globl	main`,
      `.type	main, @function`,
      `main:`,
      `.LFB124:`,
      `.cfi_startproc`,
      `movl	%edi, 12(%rsp)`,
      `movq	%rsi, (%rsp)`,
      // A word list is a linked list of word headers.
      // Each word list is a cell that points to the first header.
      // The indirection is needed so that a wordlist has a fixed identity,
      // even as it grows.
      // searchIndex is the index of the topmost wordlist in the search order.
      // searchArray is the buffer, with room for 16 searches.
      // compilationWordlist points to the current compilation wordlist.
      // Both of those default to the main Forth wordlist.
      // That main wordlist is pre-allocated as forthWordlist.
      `movq    $header_c_symbol, %rax`,
      `movq	%rax, forthWordlist(%rip)`,
      `leaq    forthWordlist(%rip), %rax`,
      `movq	%rax, searchArray(%rip)`,
      `movq	%rax, compilationWordlist(%rip)`,

      `movq	$10, base(%rip)`,
      `movq	$0, inputIndex(%rip)`,
      `movq	inputIndex(%rip), %rcx`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `movq	%rdx, %rsi`,
      `salq	$5, %rsi`,
      `addq	$inputSources+8, %rsi`,
      `movq	$0, (%rsi)`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rax, %rsi`,
      `salq	$5, %rsi`,
      `addq	$inputSources, %rsi`,
      `movq	%rdx, (%rsi)`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `salq	$5, %rcx`,
      `movq	%rcx, %rdx`,
      `addq	$inputSources+16, %rdx`,
      `movq	%rax, (%rdx)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `subl	$1, 12(%rsp)`,
      `jmp	.L334`,
      `.L336:`,
      `addq	$1, inputIndex(%rip)`,
      `movq	inputIndex(%rip), %rbx`,
      `movl	12(%rsp), %eax`,
      `cltq`,
      `leaq	0(,%rax,8), %rdx`,
      `movq	(%rsp), %rax`,
      `addq	%rdx, %rax`,
      `movl	$.LC96, %esi`,
      `movq	(%rax), %rdi`,
      `call	fopen@PLT`,
      `movq	%rax, %rdx`,
      `movq	%rbx, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.L335`,
      `movl	12(%rsp), %eax`,
      `cltq`,
      `leaq	0(,%rax,8), %rdx`,
      `movq	(%rsp), %rax`,
      `addq	%rdx, %rax`,
      `movq	(%rax), %rdx`,
      `movl	$.LC131, %esi`,
      `movq	stderr(%rip), %rdi`,
      `movl	$0, %eax`,
      `call	fprintf@PLT`,
      `movl	$1, %edi`,
      `call	exit@PLT`,
      `.L335:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `subl	$1, 12(%rsp)`,
      `.L334:`,
      `cmpl	$0, 12(%rsp)`,
      `jg	.L336`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_file_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_file_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_facility_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_facility_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_tools_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_tools_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_exception_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_exception_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_ext_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_ext_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_core_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_core_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `call	init_primitives@PLT`,
      `call	init_superinstructions@PLT`,
      `call	quit_@PLT`,
      `movl	$0, %eax`,
      `addq	$32, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `popq	%rbx`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE124:`,
      `.size	main, .-main`,


      `.globl	init_primitives`,
      `.type	init_primitives, @function`,
      `init_primitives:`,
      `.LFB125:`,
      `.cfi_startproc`,
      initWord('plus'),
      initWord('minus'),
      initWord('times'),
      initWord('div'),
      initWord('udiv'),
      initWord('MOD'),
      initWord('UMOD'),
      initWord('AND'),
      initWord('OR'),
      initWord('XOR'),
      initWord('LSHIFT'),
      initWord('RSHIFT'),
      initWord('BASE'),
      initWord('less_than'),
      initWord('less_than_unsigned'),
      initWord('equal'),
      initWord('DUP'),
      initWord('SWAP'),
      initWord('DROP'),
      initWord('OVER'),
      initWord('ROT'),
      initWord('neg_rot'),
      initWord('two_drop'),
      initWord('two_dup'),
      initWord('two_swap'),
      initWord('two_over'),
      initWord('to_r'),
      initWord('from_r'),
      initWord('fetch'),
      initWord('store'),
      initWord('cfetch'),
      initWord('cstore'),
      initWord('raw_alloc'),
      initWord('here_ptr'),
      initWord('STATE'),
      initWord('branch'),
      initWord('zbranch'),
      initWord('EXECUTE'),
      initWord('EVALUATE'),
      initWord('REFILL'),
      initWord('ACCEPT'),
      initWord('KEY'),
      initWord('latest'),
      initWord('in_ptr'),
      initWord('EMIT'),
      initWord('SOURCE'),
      initWord('source_id'),
      initWord('size_cell'),
      initWord('size_char'),
      initWord('CELLS'),
      initWord('CHARS'),
      initWord('unit_bits'),
      initWord('stack_cells'),
      initWord('return_stack_cells'),
      initWord('to_does'),
      initWord('to_cfa'),
      initWord('to_body'),
      initWord('last_word'),
      initWord('docol'),
      initWord('dolit'),
      initWord('dostring'),
      initWord('dodoes'),
      initWord('PARSE'),
      initWord('parse_name'),
      initWord('to_number'),
      initWord('CREATE'),
      initWord('find'),
      initWord('DEPTH'),
      initWord('sp_fetch'),
      initWord('sp_store'),
      initWord('rp_fetch'),
      initWord('rp_store'),
      initWord('QUIT'),
      initWord('BYE'),
      initWord('compile_comma'),
      initWord('debug_break'),
      initWord('close_file'),
      initWord('create_file'),
      initWord('open_file'),
      initWord('delete_file'),
      initWord('file_position'),
      initWord('file_size'),
      initWord('file_size'),
      initWord('include_file'),
      initWord('read_file'),
      initWord('read_line'),
      initWord('reposition_file'),
      initWord('resize_file'),
      initWord('write_file'),
      initWord('write_line'),
      initWord('flush_file'),
      initWord('colon'),
      initWord('colon_no_name'),
      initWord('EXIT'),
      initWord('semicolon'),
      initWord('LITERAL'),
      initWord('compile_literal'),
      initWord('compile_zbranch'),
      initWord('compile_branch'),
      initWord('control_flush'),
      initWord('UTIME'),
      initWord('loop_end'),

      initWord('CCALL0'),
      initWord('CCALL1'),
      initWord('CCALL2'),
      initWord('CCALL3'),
      initWord('CCALL4'),
      initWord('CCALL5'),
      initWord('CCALL6'),
      initWord('c_library'),
      initWord('c_symbol'),

      initWord('dictionary_info'),
      initWord('two_fetch'),
      initWord('two_store'),

      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE125:`,
      `.size	init_primitives, .-init_primitives`,
    ];
  },

  initSuperinstructions(superinstructions) {
    const code = [
      `.globl	init_superinstructions`,
      `.type	init_superinstructions, @function`,
      `init_superinstructions:`,
      `.LFB168:`,
      `.cfi_startproc`,
      `movl	$0, nextSuperinstruction(%rip)`,
    ];

    // Superinstructions are stored as bytes, in order.
    // Since this is a little-endian machine, the first key is in the low byte.
    // 0 is not a valid key! It means there's no superinstruction there.
    for (const sup of superinstructions) {
      // Superinstructions are struct { code* impl, super_key_t key }
      // super_key_t is uint32_t. So they're 12 bytes, but the array is aligned
      // to 16 bytes.
      // edx holds the combined key.
      code.push(`xorl %edx, %edx`);
      for (let i = 0; i < sup.parts.length; i++) {
        // Uses %eax for the next key byte, then or it into edx.
        code.push(`movl	key_${sup.parts[i]}(%rip), %eax`);
        if (i > 0) {
          // Shift it up the right amount.
          code.push(`sall	$${i * 8}, %eax`);
        }
        code.push(`orl	%eax, %edx`);
      }

      // Now use eax to index into the table.
      code.push(`movl	nextSuperinstruction(%rip), %eax`);
      code.push(`cltq`);
      code.push(`salq	$4, %rax`); // 16 bytes per entry.
      code.push(`addq	$superinstructions, %rax`);
      code.push(`movq	$code_superinstruction_${sup.parts.join('_')}, (%rax)`);
      code.push(`movl	%edx, 8(%rax)`);

      // TODO This variable could be dropped, or pushed into a register.
      // Increment nextSuperinstruction
      code.push(`movl	nextSuperinstruction(%rip), %eax`);
      code.push(`leal	1(%rax), %edx`);
      code.push(`movl	%edx, nextSuperinstruction(%rip)`);
    }

    return code.concat([
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LFE168:`,
      `.size	init_superinstructions, .-init_superinstructions`,
    ]);
  },
};

module.exports = md;

