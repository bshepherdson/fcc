const md = {
  ip: '%rbp',
  sp: '%rbx',
  tos: 'XXX_NO_TOS_XXX',
  rsp: 'rsp(%rip)',

  t1: '%rax',
  t2: '%rdx',
  t3: '%rdi',
  t4: '%rsi',

  previous: '0',
  key: 1,

  poprsp(reg) {
    return [
      `movq   ${this.rsp}, ${reg}`,
      `movq   (${reg}), ${reg}`,
      `addq   $8, ${this.rsp}`,
    ];
  },
  pushrsp(reg, thru) {
    return [
      `movq   ${this.rsp}, ${thru}`,
      `subq   $8, ${thru}`,
      `movq   ${thru}, ${this.rsp}`,
      `movq   ${reg}, (${thru})`,
    ];
  },

  next() {
    return [
      `movq (${this.ip}), ${this.t1}`,
      `addq $8, ${this.ip}`,
      `jmp *${this.t1}`,
    ];
  },

  exitNext() {
    return [
      `movq ${this.rsp}, ${this.t1}`,
      `leaq 8(${this.t1}), ${this.t2}`,
      `movq ${this.t2}, ${this.rsp}`,
      `movq (${this.t1}), ${this.ip}`,
      this.next(),
    ];
  },

  nativeWord(prim) {
    const codeName = prim.name;
    const forthName = prim.forthName || prim.name;
    const code = prim.x86_64 || prim.code;
    const length = forthName.length + (prim.immediate ? 512 : 0);

    const ret = [
      `.globl header_${codeName}`,
      `.section .rodata`,
      `.str_${codeName}:`,
      `.string "${forthName}"`,
      `.data`,
      `.align 32`,
      `.type header_${codeName}, @object`,
      `.size header_${codeName}, 32`,
      `header_${codeName}:`,
      `.quad ${this.previous}`,
      `.quad ${length}`,
      `.quad .str_${codeName}`,
      `.quad code_${codeName}`,
      `.globl key_${codeName}`,
      `.align 4`,
      `.type key_${codeName}, @object`,
      `.size key_${codeName}, 4`,
      `key_${codeName}:`,
      `.long ${this.key++}`,
      `.text`,
      `.globl code_${codeName}`,
      `.type code_${codeName}, @function`,
      `code_${codeName}:`,
      code,
      `.size code_${codeName}, .-code_${codeName}`,
    ];
    this.previous = `header_${codeName}`;
    return ret;
  },

  superinstruction(sup) {
    const name = sup.parts.join('_');
    return [
      `.globl	code_superinstruction_${name}`,
      `.type	code_superinstruction_${name}, @function`,
      `code_superinstruction_${name}:`,
      `.cfi_startproc`,
      sup.x86_64 || sup.code,
      `.cfi_endproc`,
      `.size	code_superinstruction_${name}, .-code_superinstruction_${name}`,
    ];
  },

  preamble() {
    function initWord(name) {
      return [
        `movl	key_${name}(%rip), %eax`,
        `leal	-1(%rax), %edx`,
        `movl	key_${name}(%rip), %eax`,
        `movl	%edx, %ecx`,
        `salq	$4, %rcx`,
        `addq	$primitives, %rcx`,
        `movq	$code_${name}, (%rcx)`,
        `movl	%edx, %edx`,
        `salq	$4, %rdx`,
        `addq	$primitives+8, %rdx`,
        `movl	%eax, (%rdx)`,
      ];
    }

    return [
      `.include "common/support.s"`,

      `.section	.rodata`,
      `.align 16`,
      `.LC42:`,
      `.string	"> "`,

      `.text`,
      //`.globl refill_evaluate_pop`,
      //`.type	refill_, @function`,
      //`.cfi_startproc`,
      //`refill_evaluate_pop:`,
      //this.exitNext(),
      //`.cfi_endproc`,
      //`.size	refill_evaluate_pop, .-refill_evaluate_pop`,

      `.globl	refill_`,
      `.type	refill_, @function`,
      `refill_:`,
      `.LFB43:`,
      `.cfi_startproc`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$-1, %rax`,
      `jne	.L54`,
      `subq	$1, inputIndex(%rip)`,
      `movq	rsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, rsp(%rip)`,
      `movq	(%rax), %rbp`,
      this.next(),
      `.L54:`,
      `pushq	%r12`,
      `.cfi_def_cfa_offset 16`,
      `.cfi_offset 3, -16`,
      `subq	$16, %rsp`,
      `.cfi_def_cfa_offset 32`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.L55`,
      `movl	$.LC42, %edi`,

      `# readline uses xmm0 kinds of instructions, which requires the`,
      `# target (the stack in this case) be 16-byte aligned.`,
      `# So I move the stack here and save its value in %r14, which is`,
      `# callee-saved.`,
      `movq    %rsp, %r14`,
      `movq    $15, %rax`,
      `notq    %rax`,
      `andq    %rax, %rsp`,

      `call	readline@PLT`,
      `movq    %rax, str1(%rip)`,
      `# Restore %rsp`,
      `movq    %r14, %rsp`,

      `movq	inputIndex(%rip), %r12`,
      `movq	str1(%rip), %rdi`,
      `call	strlen@PLT`,
      `movq	%rax, %rdx`,
      `movq	%r12, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$5, %rdx`,
      `leaq	inputSources+24(%rdx), %rcx`,
      `movq	%rax, %rdx`,
      `movq	str1(%rip), %rsi`,
      `movq	(%rcx), %rdi`,
      `call	strncpy@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	str1(%rip), %rdi`,
      `call	free@PLT`,
      `movq	$-1, %rax`,
      `jmp	.L56`,
      `.L55:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `andl	$1, %eax`,
      `testq	%rax, %rax`,
      `je	.L57`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `andq	$-2, %rax`,
      `movq	%rax, 8(%rsp)`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rdx`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rax`,
      `cmpq	%rax, %rdx`,
      `jb	.L58`,
      `subq	$1, inputIndex(%rip)`,
      `movl	$0, %eax`,
      `jmp	.L56`,
      `.L58:`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	%rax, str1(%rip)`,
      `jmp	.L59`,
      `.L61:`,
      `addq	$1, str1(%rip)`,
      `.L59:`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rdx`,
      `movq	str1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jbe	.L60`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$10, %al`,
      `jne	.L61`,
      `.L60:`,
      `movq	inputIndex(%rip), %rcx`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	str1(%rip), %rdx`,
      `subq	%rax, %rdx`,
      `movq	%rcx, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rdx`,
      `movq	8(%rsp), %rax`,
      `movq	(%rax), %rax`,
      `movq	inputIndex(%rip), %rcx`,
      `salq	$5, %rcx`,
      `addq	$inputSources+24, %rcx`,
      `movq	%rax, %rsi`,
      `movq	(%rcx), %rdi`,
      `call	strncpy@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rdx`,
      `movq	str1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jbe	.L62`,
      `movq	str1(%rip), %rax`,
      `addq	$1, %rax`,
      `jmp	.L63`,
      `.L62:`,
      `movq	8(%rsp), %rax`,
      `movq	8(%rax), %rax`,
      `.L63:`,
      `movq	8(%rsp), %rdx`,
      `movq	%rax, (%rdx)`,
      `movq	$-1, %rax`,
      `jmp	.L56`,
      `.L57:`,
      `movq	$0, str1(%rip)`,
      `movq	$0, tempSize(%rip)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `movq	%rax, %rdx`,
      `movl	$tempSize, %esi`,
      `movl	$str1, %edi`,
      `call	getline@PLT`,
      `movq	%rax, c1(%rip)`,
      `movq	c1(%rip), %rax`,
      `cmpq	$-1, %rax`,
      `jne	.L64`,
      `subq	$1, inputIndex(%rip)`,
      `movl	$0, %eax`,
      `jmp	.L56`,
      `.L64:`,
      `movq	str1(%rip), %rdx`,
      `movq	c1(%rip), %rax`,
      `addq	%rdx, %rax`,
      `subq	$1, %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$10, %al`,
      `jne	.L65`,
      `subq	$1, c1(%rip)`,
      `.L65:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	c1(%rip), %rdx`,
      `movq	str1(%rip), %rsi`,
      `movq	(%rax), %rdi`,
      `call	strncpy@PLT`,
      `movq	str1(%rip), %rdi`,
      `call	free@PLT`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `leaq	inputSources(%rax), %rdx`,
      `movq	c1(%rip), %rax`,
      `movq	%rax, (%rdx)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	$-1, %rax`,
      `.L56:`,
      `addq	$16, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `popq	%r12`,
      `.cfi_restore 3`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LFE43:`,
      `.size	refill_, .-refill_`,



      // parse_name_ in C uses c1 and str1; parse_name_stacked calls that but
      // then pushes the resulting values onto the stack.
      `.globl parse_name_stacked`,
      `.type	parse_name_stacked, @function`,
      `.cfi_startproc`,
      `parse_name_stacked:`,
      `call parse_name_@PLT`,
      `subq $16, %rbx`,
      `movq str1(%rip), %rax`,
      `movq %rax, 8(%rbx)`,
      `movq c1(%rip), %rax`,
      `movq %rax, (%rbx)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.size	parse_name_stacked, .-parse_name_stacked`,

      `.globl	to_number_int_`,
      `.type	to_number_int_, @function`,
      `to_number_int_:`,
      `.LmdFB69:`,
      `.cfi_startproc`,
      `movq	$0, c1(%rip)`,
      `jmp	.Lmd116`,
      `.Lmd117:`,
      `movq	c1(%rip), %rax`,
      `movq	24(%rbx), %rsi`,
      `movq	c1(%rip), %rdx`,
      `sall	$3, %edx`,
      `movl	%edx, %ecx`,
      `shrq	%cl, %rsi`,
      `movq	%rsi, %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `movq	c1(%rip), %rax`,
      `addq	$8, %rax`,
      `movq	16(%rbx), %rdx`,
      `movq	%rdx, %rsi`,
      `movq	c1(%rip), %rdx`,
      `sall	$3, %edx`,
      `movl	%edx, %ecx`,
      `shrq	%cl, %rsi`,
      `movq	%rsi, %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `addq	$1, c1(%rip)`,
      `.Lmd116:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$7, %rax`,
      `jle	.Lmd117`,
      `jmp	.Lmd118`,
      `.Lmd126:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `movsbq	%al, %rax`,
      `movq	%rax, c1(%rip)`,
      `movq	c1(%rip), %rax`,
      `cmpq	$47, %rax`,
      `jle	.Lmd119`,
      `movq	c1(%rip), %rax`,
      `cmpq	$57, %rax`,
      `jg	.Lmd119`,
      `subq	$48, c1(%rip)`,
      `jmp	.Lmd120`,
      `.Lmd119:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$64, %rax`,
      `jle	.Lmd121`,
      `movq	c1(%rip), %rax`,
      `cmpq	$90, %rax`,
      `jg	.Lmd121`,
      `movq	c1(%rip), %rax`,
      `subq	$55, %rax`,
      `movq	%rax, c1(%rip)`,
      `jmp	.Lmd120`,
      `.Lmd121:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$96, %rax`,
      `jle	.Lmd122`,
      `movq	c1(%rip), %rax`,
      `cmpq	$122, %rax`,
      `jg	.Lmd122`,
      `movq	c1(%rip), %rax`,
      `subq	$87, %rax`,
      `movq	%rax, c1(%rip)`,
      `.Lmd120:`,
      `movq	c1(%rip), %rdx`,
      `movq	tempSize(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jge	.Lmd129`,
      `movq	$0, c3(%rip)`,
      `jmp	.Lmd124`,
      `.Lmd125:`,
      `movq	c3(%rip), %rax`,
      `addq	$numBuf, %rax`,
      `movzbl	(%rax), %eax`,
      `movzbl	%al, %eax`,
      `imulq	tempSize(%rip), %rax`,
      `movq	%rax, %rdx`,
      `movq	c1(%rip), %rax`,
      `addq	%rdx, %rax`,
      `movq	%rax, c2(%rip)`,
      `movq	c3(%rip), %rax`,
      `movq	c2(%rip), %rdx`,
      `movb	%dl, numBuf(%rax)`,
      `movq	c2(%rip), %rax`,
      `sarq	$8, %rax`,
      `movzbl	%al, %eax`,
      `movq	%rax, c1(%rip)`,
      `addq	$1, c3(%rip)`,
      `.Lmd124:`,
      `movq	c3(%rip), %rax`,
      `cmpq	$15, %rax`,
      `jle	.Lmd125`,
      `movq	(%rbx), %rax`,
      `subq	$1, %rax`,
      `movq	%rax, (%rbx)`,
      `addq	$1, str1(%rip)`,
      `.Lmd118:`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jg	.Lmd126`,
      `jmp	.Lmd122`,
      `.Lmd129:`,
      `nop`,
      `.Lmd122:`,
      `movq	$0, 16(%rbx)`,
      `movq	$0, 24(%rbx)`,
      `movq	$0, c1(%rip)`,
      `jmp	.Lmd127`,
      `.Lmd128:`,
      `movq	c1(%rip), %rax`,
      `addq	$numBuf, %rax`,
      `movzbl	(%rax), %eax`,
      `movzbl	%al, %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `salq	%cl, %rdx`,
      `movq	%rdx, %rax`,

      `orq     24(%rbx), %rax`,
      `movq    %rax, 24(%rbx)`,

      `movq	c1(%rip), %rax`,
      `addq	$8, %rax`,
      `movzbl	numBuf(%rax), %eax`,
      `movzbl	%al, %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `salq	%cl, %rdx`,
      `movq	%rdx, %rax`,
      `movq	%rax, %rcx`,

      `orq     %rcx, 16(%rbx)`,
      `addq	$1, c1(%rip)`,
      `.Lmd127:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$7, %rax`,
      `jle	.Lmd128`,
      `movq	str1(%rip), %rax`,
      `movq	%rax, 8(%rbx)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE69:`,
      `.size	to_number_int_, .-to_number_int_`,
      `.globl	to_number_`,
      `.type	to_number_, @function`,
      `to_number_:`,
      `.LmdFB70:`,
      `.cfi_startproc`,
      `movq	base(%rip), %rax`,
      `movq	%rax, tempSize(%rip)`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, str1(%rip)`,
      `call	to_number_int_@PLT`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE70:`,
      `.size	to_number_, .-to_number_`,
      `.globl	parse_number_`,
      `.type	parse_number_, @function`,
      `parse_number_:`,
      `.LmdFB71:`,
      `.cfi_startproc`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, str1(%rip)`,
      `movq	base(%rip), %rax`,
      `movq	%rax, tempSize(%rip)`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$36, %al`,
      `je	.Lmd132`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$35, %al`,
      `je	.Lmd132`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$37, %al`,
      `jne	.Lmd133`,
      `.Lmd132:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$36, %al`,
      `je	.Lmd134`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$35, %al`,
      `jne	.Lmd135`,
      `movl	$10, %eax`,
      `jmp	.Lmd137`,
      `.Lmd135:`,
      `movl	$2, %eax`,
      `jmp	.Lmd137`,
      `.Lmd134:`,
      `movl	$16, %eax`,
      `.Lmd137:`,
      `movq	%rax, tempSize(%rip)`,
      `addq	$1, str1(%rip)`,
      `subq	$1, (%rbx)`,
      `jmp	.Lmd138`,
      `.Lmd133:`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$39, %al`,
      `jne	.Lmd138`,
      `subq    $3, (%rbx)`,
      `addq    $3, 8(%rbx)`,
      `movq	str1(%rip), %rax`,
      `addq	$1, %rax`,
      `movsbq	(%rax), %rax`,
      `movq	%rax, 24(%rbx)`,
      `jmp	.Lmd131`,
      `.Lmd138:`,
      `movb	$0, ch1(%rip)`,
      `movq	str1(%rip), %rax`,
      `movzbl	(%rax), %eax`,
      `cmpb	$45, %al`,
      `jne	.Lmd140`,
      `subq    $1, (%rbx)`,
      `addq	$1, str1(%rip)`,
      `movb	$1, ch1(%rip)`,
      `.Lmd140:`,
      `call	to_number_int_@PLT`,
      `movzbl	ch1(%rip), %eax`,
      `testb	%al, %al`,
      `je	.Lmd131`,

      `notq    16(%rbx)`,
      `movq    24(%rbx), %rax`,
      `notq    %rax`,
      `addq    $1, %rax`,
      `movq    %rax, 24(%rbx)`,

      `testq	%rax, %rax`,
      `jne	.Lmd131`,
      `addq	$1, 16(%rbx)`,
      `.Lmd131:`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE71:`,
      `.size	parse_number_, .-parse_number_`,
      `.globl	find_`,
      `.type	find_, @function`,
      `find_:`,
      `movq    searchIndex(%rip), %r12    # r12 is reserved for the index.`,
      `.LmdF159:`,
      `leaq    searchArray(%rip), %rax`,
      `movq    (%rax,%r12,8), %rax`,
      `movq    (%rax), %rax`,
      `movq    %rax, tempHeader(%rip)   # Store it in tempHeader.`,
      `jmp     .LmdF151`,

      `.LmdF156:`,
      `movq    tempHeader(%rip), %rax`,
      `movq    8(%rax), %rax  # The length word.`,
      `andl	$511, %eax     # The length/hidden mask`,
      `movq    (%rbx), %rcx`,
      `cmpq    %rcx, %rax`,
      `jne     .LmdF152`,

      `# If we're still here, they're the same length and not hidden.`,
      `find_debug:`,
      `movq    tempHeader(%rip), %rax`,
      `movq    16(%rax), %rdi  # 1st arg: pointer to this word's name.`,
      `movq    8(%rbx), %rsi   # 2nd arg: pointer to target name.`,
      `movq    (%rbx), %rdx    # 3rd arg: length.`,

      `# %rsp needs to be aligned to 16 bytes for C calls, but it already is,`,
      `# because find_ is a C call itself.`,
      `call strncasecmp@PLT`,
      `testl   %eax, %eax  # ZF=1 when the response was 0, meaning equal.`,
      `jne  .LmdF152  # If it's not equal, we didn't find it.`,

      `# If they are equal, we found it.`,
      `find_found:`,
      `movq    tempHeader(%rip), %rax`,
      `addq    $24, %rax`,
      `movq    %rax, 8(%rbx)   # CFA in next-but-top.`,

      `movq    tempHeader(%rip), %rax`,
      `movq    8(%rax), %rax   # Length`,
      `andl    $512, %eax      # Immediate flag`,
      `testl   %eax, %eax      # ZF=1 when not immediate`,
      `jne     .LmdF153          # Set 1 when immediate`,
      `movq    $-1, %rax`,
      `jmp     .LmdF154`,
      `.LmdF153:`,
      `movq    $1, %rax`,
      `.LmdF154:`,
      `movq    %rax, (%rbx)`,
      `jmp     .LmdF149`,

      `.LmdF152: # Mismatch, keep searching this linked list.`,
      `movq    tempHeader(%rip), %rax`,
      `movq    (%rax), %rax`,
      `movq    %rax, tempHeader(%rip)`,

      `.LmdF151:`,
      `movq    tempHeader(%rip), %rax`,
      `testq   %rax, %rax`,
      `jne     .LmdF156  # Nonzero, so loop back.`,
      `.LmdF150: # Reached the end of a wordlist. Try the next one, if any.`,
      `testq   %r12, %r12`,
      `je      .LmdF158  # Index = 0, bail.`,
      `subq    $1, %r12 # If nonzero, subtract and loop.`,
      `jmp     .LmdF159`,

      `.LmdF160:`,
      `nop`,
      `.LmdF158: # Run out of wordlists too.`,
      `movq $0, %rax`,
      `movq %rax, 8(%rbx) # 0 underneath`,
      `movq %rax, (%rbx)  # 0 on top`,
      `.LmdF149: # Returning`,
      `ret`,
      `.size	find_, .-find_`,



      `.globl	key_call_`,
      `.data`,
      `.align 4`,
      `.type	key_call_, @object`,
      `.size	key_call_, 4`,
      `key_call_:`,
      `.long	100`,
      `.text`,
      `.globl	call_`,
      `.type	call_, @function`,
      `call_:`,
      `.LmdFB88:`,
      `.cfi_startproc`,
      `movq	(%rbp), %rax`,
      `addq    $8, %rbp`,
      `movq	rsp(%rip), %r12`,
      `subq	$8, %r12`,
      `movq	%r12, rsp(%rip)`,
      `movq	%rbp, (%r12)`,
      `movq	%rax, %rbp`,
      this.next(),
      `.cfi_endproc`,
      `.LmdFE88:`,
      `.size	call_, .-call_`,


      `.globl	lookup_primitive`,
      `.type	lookup_primitive, @function`,
      `lookup_primitive:`,
      `.LmdFB89:`,
      `.cfi_startproc`,
      `movq	$0, c2(%rip)`,
      `jmp	.Lmd179`,
      `.Lmd182:`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$primitives, %rax`,
      `movq	(%rax), %rdx`,
      `movq	c1(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jne	.Lmd180`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$primitives+8, %rax`,
      `movl	(%rax), %eax`,
      `movl	%eax, key1(%rip)`,
      `jmp	.Lmd183`,
      `.Lmd180:`,
      `addq	$1, c2(%rip)`,
      `.Lmd179:`,
      `movl	primitive_count(%rip), %eax`,
      `movslq	%eax, %rdx`,
      `movq	c2(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jg	.Lmd182`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `movl	$40, %edi`,
      `call	exit@PLT`,
      `.Lmd183:`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE89:`,
      `.size	lookup_primitive, .-lookup_primitive`,


      `.globl	drain_queue_`,
      `.type	drain_queue_, @function`,
      `drain_queue_:`,
      `.LmdFB90:`,
      `.cfi_startproc`,
      `movl	$0, key1(%rip)`,
      `movq	queue(%rip), %rax`,
      `movq	%rax, tempQueue(%rip)`,
      `movq	$0, c1(%rip)`,
      `jmp	.Lmd188`,
      `.Lmd189:`,
      `movq	tempQueue(%rip), %rax`,
      `movl	24(%rax), %edx`,
      `movq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	%eax, %ecx`,
      `sall	%cl, %edx`,
      `movl	%edx, %eax`,
      `orl	%eax, key1(%rip)`,
      `addq	$1, c1(%rip)`,
      `movq	tempQueue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, tempQueue(%rip)`,
      `.Lmd188:`,
      `movq	tempQueue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd189`,
      `jmp	.Lmd190`,
      `.Lmd199:`,
      `movq	$0, c2(%rip)`,
      `jmp	.Lmd191`,
      `.Lmd198:`,
      `movq	c2(%rip), %rax`,
      `salq	$4, %rax`,
      `addq	$superinstructions+8, %rax`,
      `movl	(%rax), %edx`,
      `movl	key1(%rip), %eax`,
      `cmpl	%eax, %edx`,
      `jne	.Lmd192`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	c2(%rip), %rdx`,
      `salq	$4, %rdx`,
      `addq	$superinstructions, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `jmp	.Lmd193`,
      `.Lmd195:`,
      `movq	queue(%rip), %rax`,
      `movzbl	8(%rax), %eax`,
      `testb	%al, %al`,
      `je	.Lmd194`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	16(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `.Lmd194:`,
      `movq	queue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queue(%rip)`,
      `subl	$1, queue_length(%rip)`,
      `subq	$1, c1(%rip)`,
      `.Lmd193:`,
      `movq	c1(%rip), %rax`,
      `testq	%rax, %rax`,
      `jg	.Lmd195`,
      `movq	queue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd202`,
      `movq	$0, queueTail(%rip)`,
      `jmp	.Lmd202`,
      `.Lmd192:`,
      `addq	$1, c2(%rip)`,
      `.Lmd191:`,
      `movl	nextSuperinstruction(%rip), %eax`,
      `movslq	%eax, %rdx`,
      `movq	c2(%rip), %rax`,
      `cmpq	%rax, %rdx`,
      `jg	.Lmd198`,
      `subq	$1, c1(%rip)`,
      `movl	$4, %eax`,
      `subq	c1(%rip), %rax`,
      `sall	$3, %eax`,
      `movl	$-1, %edx`,
      `movl	%eax, %ecx`,
      `shrl	%cl, %edx`,
      `movl	%edx, %eax`,
      `andl	%eax, key1(%rip)`,
      `.Lmd190:`,
      `movq	c1(%rip), %rax`,
      `cmpq	$1, %rax`,
      `jg	.Lmd199`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `movq	queue(%rip), %rax`,
      `movzbl	8(%rax), %eax`,
      `testb	%al, %al`,
      `je	.Lmd200`,
      `movq	dsp(%rip), %rax`,
      `leaq	8(%rax), %rdx`,
      `movq	%rdx, dsp(%rip)`,
      `movq	queue(%rip), %rdx`,
      `movq	16(%rdx), %rdx`,
      `movq	%rdx, (%rax)`,
      `.Lmd200:`,
      `movq	queue(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queue(%rip)`,
      `movq	queue(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd201`,
      `movq	$0, queueTail(%rip)`,
      `.Lmd201:`,
      `subl	$1, queue_length(%rip)`,
      `jmp	.Lmd187`,
      `.Lmd202:`,
      `nop`,
      `.Lmd187:`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE90:`,
      `.size	drain_queue_, .-drain_queue_`,


      `.globl	bump_queue_tail_`,
      `.type	bump_queue_tail_, @function`,
      `bump_queue_tail_:`,
      `.LmdFB91:`,
      `.cfi_startproc`,
      `movq	queueTail(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd204`,
      `movl	next_queue_source(%rip), %eax`,
      `leal	1(%rax), %edx`,
      `movl	%edx, next_queue_source(%rip)`,
      `movslq	%eax, %rdx`,
      `movq	%rdx, %rax`,
      `salq	$2, %rax`,
      `addq	%rdx, %rax`,
      `salq	$3, %rax`,
      `addq	$queueSource, %rax`,
      `movq	%rax, queueTail(%rip)`,
      `movq	queueTail(%rip), %rax`,
      `movq	%rax, queue(%rip)`,
      `jmp	.Lmd205`,
      `.Lmd204:`,
      `movq	queueTail(%rip), %rcx`,
      `movl	next_queue_source(%rip), %eax`,
      `leal	1(%rax), %edx`,
      `movl	%edx, next_queue_source(%rip)`,
      `movslq	%eax, %rdx`,
      `movq	%rdx, %rax`,
      `salq	$2, %rax`,
      `addq	%rdx, %rax`,
      `salq	$3, %rax`,
      `addq	$queueSource, %rax`,
      `movq	%rax, 32(%rcx)`,
      `movq	queueTail(%rip), %rax`,
      `movq	32(%rax), %rax`,
      `movq	%rax, queueTail(%rip)`,
      `.Lmd205:`,
      `movq	queueTail(%rip), %rax`,
      `movq	$0, 32(%rax)`,
      `andl	$3, next_queue_source(%rip)`,
      `addl	$1, queue_length(%rip)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE91:`,
      `.size	bump_queue_tail_, .-bump_queue_tail_`,


      `.globl	compile_`,
      `.type	compile_, @function`,
      `compile_:`,
      `.LmdFB92:`,
      `.cfi_startproc`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$3, %eax`,
      `jle	.Lmd207`,
      `call	drain_queue_@PLT`,
      `.Lmd207:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	(%rbx), %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$code_docol, %rax`,
      `jne	.Lmd208`,
      `movq	queueTail(%rip), %rax`,
      `movq	$call_, (%rax)`,
      `movb	$1, 8(%rax)`,
      `movq	%rax, %rdx`,

      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `addq	$8, %rax`,
      `movq	%rax, 16(%rdx)`,

      `movq	queueTail(%rip), %rax`,
      `movl	key_call_(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `jmp	.Lmd213`,
      `.Lmd208:`,
      `movq	(%rbx), %rax`,
      `movq	(%rax), %rax`,
      `cmpq	$code_dodoes, %rax`,
      `jne	.Lmd210`,
      `movq	queueTail(%rip), %rax`,
      `movq	$code_dolit, (%rax)`,
      `movb	$1, 8(%rax)`,

      `movq	(%rbx), %rdx`,
      `addq	$16, %rdx`,
      `movq	%rdx, 16(%rax)`,
      `movl	key_dolit(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `movq	(%rbx), %rax`,
      `addq	$8, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `je	.Lmd211`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$4, %eax`,
      `jne	.Lmd212`,
      `call	drain_queue_@PLT`,
      `.Lmd212:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	$call_, (%rax)`,
      `movb	$1, 8(%rax)`,
      `movq	(%rbx), %rdx`,
      `addq	$8, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rdx, 16(%rax)`,
      `movl	key_call_(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `.Lmd211:`,
      `addq	$8, %rbx`,
      `jmp	.Lmd213`,
      `.Lmd210:`,
      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `movq	(%rax), %rax`,
      `movq	%rax, c1(%rip)`,
      `movl	$0, %eax`,
      `call	lookup_primitive@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	c1(%rip), %rdx`,
      `movq	%rdx, (%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movb	$0, 8(%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movl	key1(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `.Lmd213:`,
      `nop`,
      `addq	$8, %rsp`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE92:`,
      `.size	compile_, .-compile_`,


      `.globl	compile_lit_`,
      `.type	compile_lit_, @function`,
      `compile_lit_:`,
      `.LmdFB93:`,
      `.cfi_startproc`,
      `movl	queue_length(%rip), %eax`,
      `cmpl	$3, %eax`,
      `jle	.Lmd216`,
      `call	drain_queue_@PLT`,
      `.Lmd216:`,
      `movl	$0, %eax`,
      `call	bump_queue_tail_@PLT`,
      `movq	queueTail(%rip), %rax`,
      `movq	$code_dolit, (%rax)`,
      `movq	queueTail(%rip), %rax`,
      `movb	$1, 8(%rax)`,
      `movq	queueTail(%rip), %rdx`,
      `movq    (%rbx), %rax`,
      `addq    $8, %rbx`,
      `movq	%rax, 16(%rdx)`,
      `movq	queueTail(%rip), %rax`,
      `movl	key_dolit(%rip), %edx`,
      `movl	%edx, 24(%rax)`,
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE93:`,
      `.size	compile_lit_, .-compile_lit_`,

      `.comm	savedString,8,8`,
      `.comm	savedLength,8,8`,
      `.section	.rodata`,
      `.LmdC84:`,
      `.string	"  ok"`,
      `.LmdC85:`,
      `.string	"*** Unrecognized word: %s\\n"`,

      `.text`,
      `.globl	quit_`,
      `.type	quit_, @function`,
      `quit_:`,
      `.LmdFB94:`,
      `.cfi_startproc`,
      `subq	$8, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `.Lmd218:`,
      `movq	spTop(%rip), %rbx`,
      `movq	rspTop(%rip), %rax`,
      `movq	%rax, rsp(%rip)`,
      `movq	$0, state(%rip)`,
      `movzbl	firstQuit(%rip), %eax`,
      `testb	%al, %al`,
      `jne	.Lmd219`,
      `movq	$0, inputIndex(%rip)`,
      `.Lmd219:`,
      `movq	$.Lmd220, quit_inner(%rip)`,
      `call	refill_@PLT`,
      `.Lmd220:`,
      `call	parse_name_stacked@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd233`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd223`,
      `movl	$.LmdC84, %edi`,
      `call	puts@PLT`,
      `.Lmd223:`,
      `addq	$16, %rbx`,
      `call	refill_@PLT`,
      `jmp	.Lmd220`,
      `.Lmd233:`,
      `nop`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, savedString(%rip)`,
      `movq	(%rbx), %rax`,
      `movq	%rax, savedLength(%rip)`,
      `call	find_@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd224`,
      `subq	$16, %rbx`,
      `movq	savedLength(%rip), %rax`,
      `movq	%rax, (%rbx)`,
      `movq	savedString(%rip), %rax`,
      `movq	%rax, 8(%rbx)`,
      `call	parse_number_@PLT`,
      `movq	(%rbx), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd225`,
      `movq	state(%rip), %rax`,
      `cmpq	$1, %rax`,
      `jne	.Lmd226`,
      `addq	$24, %rbx`,
      `movl	$0, %eax`,
      `call	compile_lit_@PLT`,
      `jmp	.Lmd220`,
      `.Lmd226:`,
      `addq	$24, %rbx`,
      `jmp	.Lmd220`,
      `.Lmd225:`,
      `movq	savedLength(%rip), %rdx`,
      `movq	savedString(%rip), %rsi`,
      `movl	$tempBuf, %edi`,
      `call	strncpy@PLT`,
      `movq	savedLength(%rip), %rax`,
      `movb	$0, tempBuf(%rax)`,
      `movl	$tempBuf, %edx`,
      `movl	$.LmdC85, %esi`,
      `movq	stderr(%rip), %rdi`,
      `movl	$0, %eax`,
      `call	fprintf@PLT`,
      `jmp	.Lmd218`,
      `.Lmd224:`,
      `movq	(%rbx), %rax`,
      `cmpq	$1, %rax`,
      `je	.Lmd229`,
      `movq	state(%rip), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd230`,
      `.Lmd229:`,
      `movl	$.Lmd220, %eax`,
      `movq	%rax, quitTop(%rip)`,
      `movq	$quitTop, %rbp`,
      `movq	8(%rbx), %rax`,
      `movq	%rax, cfa(%rip)`,
      `addq	$16, %rbx`,
      `movq	cfa(%rip), %rax`,
      `movq	(%rax), %rax`,
      `#APP`,
      `# 1438 "vm.c" 1`,
      `jmpq *%rax`,
      `# 0 "" 2`,
      `#NO_APP`,
      `.Lmd230:`,
      `addq	$8, %rbx`,
      `movl	$0, %eax`,
      `call	compile_@PLT`,
      `jmp	.Lmd220`,
      `.cfi_endproc`,
      `.LmdFE94:`,
      `.size	quit_, .-quit_`,


      `.globl	file_modes`,
      `.section	.rodata`,
      `.LmdC96:`,
      `.string	"r"`,
      `.LmdC97:`,
      `.string	"r+"`,
      `.LmdC98:`,
      `.string	"rb"`,
      `.LmdC99:`,
      `.string	"r+b"`,
      `.LmdC100:`,
      `.string	"w+"`,
      `.LmdC101:`,
      `.string	"w"`,
      `.LmdC102:`,
      `.string	"w+b"`,
      `.data`,
      `.align 32`,
      `.type	file_modes, @object`,
      `.size	file_modes, 128`,
      `file_modes:`,
      `.quad	0`,
      `.quad	.LmdC96`,
      `.quad	.LmdC97`,
      `.quad	.LmdC97`,
      `.quad	0`,
      `.quad	.LmdC98`,
      `.quad	.LmdC99`,
      `.quad	.LmdC99`,
      `.quad	0`,
      `.quad	.LmdC100`,
      `.quad	.LmdC101`,
      `.quad	.LmdC100`,
      `.quad	0`,
      `.quad	.LmdC102`,
      `.quad	.LmdC81`,
      `.quad	.LmdC102`,

      `.section	.rodata`,
      `.align 8`,
      `.LmdC117:`,
      `.string	"*** Colon definition with no name\\n"`,


      `.LmdFE123:`,
      `.section	.rodata`,
      `.align 8`,
      `.LmdC131:`,
      `.string	"Could not load input file: %s\\n"`,
      `.LmdC81:`,
      `.string	"wb"`,
      `.align 8`,
      `.LmdC82:`,
      `.string	"*** Failed to open file for writing: %s\\n"`,
      `.text`,
      `.globl	main`,
      `.type	main, @function`,
      `main:`,
      `.LmdFB124:`,
      `.cfi_startproc`,
      `movl	%edi, 12(%rsp)`,
      `movq	%rsi, (%rsp)`,
      // A word list is a linked list of word headers.
      // Each word list is a cell that points to the first header.
      // The indirection is needed so that a wordlist has a fixed identity,
      // even as it grows.
      // searchIndex is the index of the topmost wordlist in the search order.
      // searchArray is the buffer, with room for 16 searches.
      // compilationWordlist points to the current compilation wordlist.
      // Both of those default to the main Forth wordlist.
      // That main wordlist is pre-allocated as forthWordlist.
      `movq    $header_c_symbol, %rax`,
      `movq	%rax, forthWordlist(%rip)`,
      `leaq    forthWordlist(%rip), %rax`,
      `movq	%rax, searchArray(%rip)`,
      `movq	%rax, compilationWordlist(%rip)`,

      `movq	$10, base(%rip)`,
      `movq	$0, inputIndex(%rip)`,
      `movq	inputIndex(%rip), %rcx`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `movq	%rdx, %rsi`,
      `salq	$5, %rsi`,
      `addq	$inputSources+8, %rsi`,
      `movq	$0, (%rsi)`,
      `salq	$5, %rdx`,
      `addq	$inputSources+8, %rdx`,
      `movq	(%rdx), %rdx`,
      `movq	%rax, %rsi`,
      `salq	$5, %rsi`,
      `addq	$inputSources, %rsi`,
      `movq	%rdx, (%rsi)`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	(%rax), %rax`,
      `salq	$5, %rcx`,
      `movq	%rcx, %rdx`,
      `addq	$inputSources+16, %rdx`,
      `movq	%rax, (%rdx)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `subl	$1, 12(%rsp)`,
      `jmp	.Lmd334`,
      `.Lmd336:`,
      `addq	$1, inputIndex(%rip)`,
      `movq	inputIndex(%rip), %rbx`,
      `movl	12(%rsp), %eax`,
      `cltq`,
      `leaq	0(,%rax,8), %rdx`,
      `movq	(%rsp), %rax`,
      `addq	%rdx, %rax`,
      `movl	$.LmdC96, %esi`,
      `movq	(%rax), %rdi`,
      `call	fopen@PLT`,
      `movq	%rax, %rdx`,
      `movq	%rbx, %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	(%rax), %rax`,
      `testq	%rax, %rax`,
      `jne	.Lmd335`,
      `movl	12(%rsp), %eax`,
      `cltq`,
      `leaq	0(,%rax,8), %rdx`,
      `movq	(%rsp), %rax`,
      `addq	%rdx, %rax`,
      `movq	(%rax), %rdx`,
      `movl	$.LmdC131, %esi`,
      `movq	stderr(%rip), %rdi`,
      `movl	$0, %eax`,
      `call	fprintf@PLT`,
      `movl	$1, %edi`,
      `call	exit@PLT`,
      `.Lmd335:`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `subl	$1, 12(%rsp)`,
      `.Lmd334:`,
      `cmpl	$0, 12(%rsp)`,
      `jg	.Lmd336`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_file_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_file_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_facility_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_facility_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_tools_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_tools_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_exception_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_exception_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_ext_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_ext_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `addq	$1, inputIndex(%rip)`,
      `movl	$16, %edi`,
      `call	malloc@PLT`,
      `movq	%rax, 24(%rsp)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_core_fs_start, (%rax)`,
      `movq	24(%rsp), %rax`,
      `movq	$_binary_core_core_fs_end, 8(%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	24(%rsp), %rdx`,
      `orq	$1, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+16, %rax`,
      `movq	%rdx, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources+8, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `salq	$5, %rax`,
      `addq	$inputSources, %rax`,
      `movq	$0, (%rax)`,
      `movq	inputIndex(%rip), %rax`,
      `movq	inputIndex(%rip), %rdx`,
      `salq	$8, %rdx`,
      `addq	$parseBuffers, %rdx`,
      `salq	$5, %rax`,
      `addq	$inputSources+24, %rax`,
      `movq	%rdx, (%rax)`,
      `call	init_primitives@PLT`,
      `call	init_superinstructions@PLT`,
      `call	quit_@PLT`,
      `movl	$0, %eax`,
      `addq	$32, %rsp`,
      `.cfi_def_cfa_offset 16`,
      `popq	%rbx`,
      `.cfi_def_cfa_offset 8`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE124:`,
      `.size	main, .-main`,


      `.globl	init_primitives`,
      `.type	init_primitives, @function`,
      `init_primitives:`,
      `.LmdFB125:`,
      `.cfi_startproc`,
      initWord('plus'),
      initWord('minus'),
      initWord('times'),
      initWord('div'),
      initWord('udiv'),
      initWord('MOD'),
      initWord('UMOD'),
      initWord('AND'),
      initWord('OR'),
      initWord('XOR'),
      initWord('LSHIFT'),
      initWord('RSHIFT'),
      initWord('BASE'),
      initWord('less_than'),
      initWord('less_than_unsigned'),
      initWord('equal'),
      initWord('DUP'),
      initWord('SWAP'),
      initWord('DROP'),
      initWord('OVER'),
      initWord('ROT'),
      initWord('neg_rot'),
      initWord('two_drop'),
      initWord('two_dup'),
      initWord('two_swap'),
      initWord('two_over'),
      initWord('to_r'),
      initWord('from_r'),
      initWord('fetch'),
      initWord('store'),
      initWord('cfetch'),
      initWord('cstore'),
      initWord('raw_alloc'),
      initWord('here_ptr'),
      initWord('STATE'),
      initWord('branch'),
      initWord('zbranch'),
      initWord('EXECUTE'),
      initWord('EVALUATE'),
      initWord('REFILL'),
      initWord('ACCEPT'),
      initWord('KEY'),
      initWord('latest'),
      initWord('in_ptr'),
      initWord('EMIT'),
      initWord('SOURCE'),
      initWord('source_id'),
      initWord('size_cell'),
      initWord('size_char'),
      initWord('CELLS'),
      initWord('CHARS'),
      initWord('unit_bits'),
      initWord('stack_cells'),
      initWord('return_stack_cells'),
      initWord('to_does'),
      initWord('to_cfa'),
      initWord('to_body'),
      initWord('last_word'),
      initWord('docol'),
      initWord('dolit'),
      initWord('dostring'),
      initWord('dodoes'),
      initWord('PARSE'),
      initWord('parse_name'),
      initWord('to_number'),
      initWord('CREATE'),
      initWord('find'),
      initWord('DEPTH'),
      initWord('sp_fetch'),
      initWord('sp_store'),
      initWord('rp_fetch'),
      initWord('rp_store'),
      initWord('QUIT'),
      initWord('BYE'),
      initWord('compile_comma'),
      initWord('debug_break'),
      initWord('close_file'),
      initWord('create_file'),
      initWord('open_file'),
      initWord('delete_file'),
      initWord('file_position'),
      initWord('file_size'),
      initWord('file_size'),
      initWord('include_file'),
      initWord('read_file'),
      initWord('read_line'),
      initWord('reposition_file'),
      initWord('resize_file'),
      initWord('write_file'),
      initWord('write_line'),
      initWord('flush_file'),
      initWord('colon'),
      initWord('colon_no_name'),
      initWord('EXIT'),
      initWord('semicolon'),
      initWord('LITERAL'),
      initWord('compile_literal'),
      initWord('compile_zbranch'),
      initWord('compile_branch'),
      initWord('control_flush'),
      initWord('UTIME'),
      initWord('loop_end'),

      initWord('CCALL0'),
      initWord('CCALL1'),
      initWord('CCALL2'),
      initWord('CCALL3'),
      initWord('CCALL4'),
      initWord('CCALL5'),
      initWord('CCALL6'),
      initWord('c_lib_loader'),
      initWord('c_symbol'),

      initWord('dictionary_info'),
      initWord('two_fetch'),
      initWord('two_store'),

      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE125:`,
      `.size	init_primitives, .-init_primitives`,
    ];
  },

  initSuperinstructions(superinstructions) {
    const code = [
      `.globl	init_superinstructions`,
      `.type	init_superinstructions, @function`,
      `init_superinstructions:`,
      `.LmdFB168:`,
      `.cfi_startproc`,
      `movl	$0, nextSuperinstruction(%rip)`,
    ];

    // Superinstructions are stored as bytes, in order.
    // Since this is a little-endian machine, the first key is in the low byte.
    // 0 is not a valid key! It means there's no superinstruction there.
    for (const sup of superinstructions) {
      // Superinstructions are struct { code* impl, super_key_t key }
      // super_key_t is uint32_t. So they're 12 bytes, but the array is aligned
      // to 16 bytes.
      // edx holds the combined key.
      code.push(`xorl %edx, %edx`);
      for (let i = 0; i < sup.parts.length; i++) {
        // Uses %eax for the next key byte, then or it into edx.
        code.push(`movl	key_${sup.parts[i]}(%rip), %eax`);
        if (i > 0) {
          // Shift it up the right amount.
          code.push(`sall	$${i * 8}, %eax`);
        }
        code.push(`orl	%eax, %edx`);
      }

      // Now use eax to index into the table.
      code.push(`movl	nextSuperinstruction(%rip), %eax`);
      code.push(`cltq`);
      code.push(`salq	$4, %rax`); // 16 bytes per entry.
      code.push(`addq	$superinstructions, %rax`);
      code.push(`movq	$code_superinstruction_${sup.parts.join('_')}, (%rax)`);
      code.push(`movl	%edx, 8(%rax)`);

      // TODO This variable could be dropped, or pushed into a register.
      // Increment nextSuperinstruction
      code.push(`movl	nextSuperinstruction(%rip), %eax`);
      code.push(`leal	1(%rax), %edx`);
      code.push(`movl	%edx, nextSuperinstruction(%rip)`);
    }

    return code.concat([
      `nop`,
      `ret`,
      `.cfi_endproc`,
      `.LmdFE168:`,
      `.size	init_superinstructions, .-init_superinstructions`,
    ]);
  },
};

module.exports = md;

